(in-package #:mang)

(defun parse-binary-feature-definition ()
  (>> (parse-constant "binary")
      (parse-whitespace)
      (parse-constant ":")
      (parse-whitespace)
      (parse-sequence (parse-identifier *mang-reserved-symbols*)
                      (>> (parse-whitespace)
                          (parse-constant ",")
                          (parse-whitespace))
                      (empty-set)
                      (lambda (feature features)
                        (with features feature)))))

(defun parse-valued-feature-definition ()
  (>>!
    _ (>> (parse-constant "valued")
          (parse-whitespace)
          (parse-constant ":")
          (parse-whitespace))
    name (parse-identifier *mang-reserved-symbols*)
    _ (>> (parse-whitespace)
          (parse-constant ":=")
          (parse-whitespace))
    values (parse-sequence (parse-identifier *mang-reserved-symbols*)
                           (>> (parse-whitespace)
                               (parse-constant ",")
                               (parse-whitespace))
                           (empty-set)
                           (lambda (value values)
                             (with values value)))
    (succeed `(,name ,values))))

(defun parse-privative-feature-definition ()
  (>> (parse-constant "privative")
      (parse-whitespace)
      (parse-constant ":")
      (parse-whitespace)
      (parse-sequence (parse-identifier *mang-reserved-symbols*)
                      (>> (parse-whitespace)
                          (parse-constant ",")
                          (parse-whitespace))
                      (empty-set)
                      (lambda (feature features)
                        (with features feature)))))

(defun parse-feature-definition ()
  (// (<$> (parse-binary-feature-definition)
           (lambda (definition)
             `(,definition
                ,(empty-map (empty-set))
                ,(empty-set))))
      (<$> (parse-valued-feature-definition)
           (lambda (definition)
             (bind (((name values)
                     definition))
               `(,(empty-set)
                  ,(map (name values))
                  ,(empty-set)))))
      (<$> (parse-privative-feature-definition)
           (lambda (definition)
             `(,(empty-set)
                ,(empty-map (empty-set))
                ,definition)))))

(defun parse-feature-section ()
  (parse-section
   "features"
   (parse-lines (parse-feature-definition)
                `(,(empty-set)
                   ,(empty-map)
                   ,(empty-set))
                (lambda (def defs)
                  (bind (((binary valued privative)
                          defs)
                         ((nbinary nvalued nprivative)
                          def))
                    `(,(union binary nbinary)
                       ,(map-union valued nvalued)
                       ,(union privative nprivative)))))))

(defun parse-feature-file ()
  (>>!
    features (parse-feature-section)
    _ (>> (parse-whitespace)
          (parse-eof))
    (succeed features)))

(defun load-feature-file (file)
  (with-open-file (stream file)
    (apply #'values
           (parser-call (parse-feature-file)
                        stream))))

(defmacro def-features-from-file!
    (binary-features valued-features privative-features file)
  (bind ((g!binary (gensym "binary"))
         (g!valued (gensym "valued"))
         (g!privative (gensym "privative")))
    `(bind (((:values ,g!binary ,g!valued ,g!privative)
             (load-feature-file ,file)))
       (defparameter ,binary-features
         ,g!binary)
       (defparameter ,valued-features
         ,g!valued)
       (defparameter ,privative-features
         ,g!privative))))

(defun parse-binary-feature-spec (binary-features)
  (declare (type set binary-features))
  (>>!
    sign (// (<$ (parse-constant "+")
                 t)
             (<$ (parse-constant "-")
                 nil))
    _ (parse-whitespace)
    feature (parse-from-set binary-features)
    (succeed `(,feature ,sign))))

(defun parse-valued-feature-spec (valued-features)
  (declare (type map valued-features))
  (>>!
    (feature values)
    (parse-from-map valued-features)
    _ (>> (parse-whitespace)
          (parse-constant "=")
          (parse-whitespace))
    value (parse-from-set values)
    (succeed `(,feature ,value))))

(defun parse-present-feature-spec (privative-features)
  (declare (type set privative-features))
  (>>!
    present? (?? (parse-constant "~")
                 (succeed nil)
                 (succeed t))
    feature (parse-from-set privative-features)
    (succeed `(,feature ,present?))))

(defun parse-feature-spec (binary-features valued-features privative-features)
  (declare (type set binary-features privative-features)
           (type map valued-features))
  (// (<$> (// (parse-binary-feature-spec binary-features)
               (parse-valued-feature-spec valued-features))
           (lambda (spec)
             (bind (((feature value)
                     spec))
               `(,(map (feature value)
                       :default (empty-set))
                  ,(empty-set)
                  ,(empty-set)))))
      (<$> (parse-present-feature-spec privative-features)
           (lambda (spec)
             (bind (((feature present?)
                     spec))
               (if present?
                   `(,(empty-map (empty-set))
                      ,(set feature)
                      ,(empty-set))
                   `(,(empty-map (empty-set))
                      ,(empty-set)
                      ,(set feature))))))))

(defun parse-feature-set-with-absent (binary-features valued-features
                                      privative-features)
  (declare (type set binary-features privative-features)
           (type map valued-features))
  (parse-w/s (>> (parse-constant "[")
                 (parse-whitespace))
             (parse-feature-spec binary-features valued-features
                                 (union (union binary-features
                                               (domain valued-features))
                                        privative-features))
             (>> (parse-whitespace)
                 (parse-constant ",")
                 (parse-whitespace))
             (>> (parse-whitespace)
                 (parse-constant "]"))
             `(,(empty-map)
               ,(empty-set)
               ,(empty-set))
             (lambda (feature features)
               (bind (((constant present absent)
                       feature)
                      ((constants presents absents)
                       features))
                 `(,(map-union constants constant)
                   ,(union presents present)
                   ,(union absents absent))))))

(defun parse-feature-set (binary-features valued-features privative-features)
  (declare (type set binary-features privative-features)
           (type map valued-features))
  (parse-w/s (>> (parse-constant "[")
                 (parse-whitespace))
             (parse-feature-spec binary-features valued-features
                                 privative-features)
             (>> (parse-whitespace)
                 (parse-constant ",")
                 (parse-whitespace))
             (>> (parse-whitespace)
                 (parse-constant "]"))
             (empty-map)
             (lambda (feature features)
               (bind (((constant present _)
                       feature))
                 (map-union (map-union constant
                                       (convert 'map
                                                present
                                                :key-fn #'identity
                                                :value-fn (constantly t)))
                            features)))))

(defun has-features? (phoneme features present absent)
  (declare (type map phoneme features))
  (and (not (@ (gmap :set (lambda (feature value)
                            (equal? (@ phoneme feature)
                                    value))
                     (:map features))
               nil))
       (bind ((features (domain phoneme)))
         (and (empty? (set-difference present features))
              (empty? (intersection absent features))))))

(defun augment-feature-set (feature-set overwrite present absent)
  (filter (lambda (k v)
            (declare (ignore v))
            (not (@ absent k)))
          (map-union (map-union feature-set overwrite)
                     (convert 'map
                              present
                              :key-fn #'identity
                              :value-fn (constantly t)))))
